# Инструкция по git (яндекс практикум)
---
## 1. Инициализируем репозиторий

Cоздать папку (например: first-project) и сделайте её Git-репозиторием: 
перейдите в неё с помощью команды ***-cd-*** и выполните ***-git init***-.

Если случайно сделали Git-репозиторием не в ту папку, её можно «разгитить». 
Для этого нужно удалить скрытую подпапку .git:
~~~
$ cd <папка с репозиторием> # перешли в папку
$ rm -rf .git # удалили подпапку .git
~~~
Что такое ***-rf***:
ключ ***-r*** (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;
ключ ***-f*** (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».

Проверка состояния репозитория — ***git status***

## 2. Добавляем файлы в репозиторий

Подготовка файлов к сохранению через команду ***-git add***.
Ключ, или флаг, ***--all*** позволяет подготовить к сохранению все файлы в репозитории.
~~~
$ git add --all # подготовили к сохранению все файлы в репозитории
~~~
Добавлять файлы можно и по одному, без ключа ***--all***.
~~~
$ git add todo.txt
$ git add readme.txt
~~~
Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка (.).
~~~
$ git add . # добавить всю текущую папку
~~~
Команда git add только запоминает текущее содержимое (контент) файла и не сохраняет содержимое файлов в репозитории. Само сохранение, 
или фиксацию состояния файлов, называют коммитом (от англ. ***commit*** — «совершать», «фиксировать»). «Сделать коммит» значит сохранить 
текущую версию файла.
Если сейчас отредактировать любой файл после комманды ***-git add***, то нужно снова ввести команду git add и передать в качестве параметра имя отредактированного файла или ключ --all.

## 3. Делаем первый коммит

_Коммит_ — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».

Сделать коммит можно командой ***git commit*** c ключом ***-m*** (от англ. message — «сообщение»), который присваивает коммиту сообщение.
~~~
$ git commit -m ‘Мой первый коммит!’ 
~~~

###Разнице между git add и git commit
Сначала команда ***git add*** сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды ***git commit*** происходит само сохранение.

## 4. Просматриваем историю коммитов

Чтобы увидеть их все, введите команду ***git log*** (от англ. log — «журнал записей»).
По умолчанию git log выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху. В этом можно убедиться, если посмотреть на дату и время их создания.

## 5. Привязываем удалённый репозиторий к локальному ***— git remote add***

Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL.
Откройть консоль, перейти в каталог локального репозитория и ввести команду ***git remote add*** (от англ. remote — «удалённый» и add — «добавить»):
~~~
$ cd ~/dev/first-project
$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git
~~~
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово ***origin***. А URL вы скопировали со страницы удалённого репозитория.
Убедиться, что репозитории связаны, — ***git remote -v***:
~~~
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 
~~~
Флаг -***v*** — короткая форма флага ***--verbose*** (англ. «подробный»). Он позволяет показать больше информации в выводе.

## 6. Синхронизируем локальный и удалённый репозитории

Отправить изменения на удалённый репозиторий — ***git push***.
Раннее прошли весь «цикл коммита»: подготовили файлы с помощью ***git add***, закоммитили их с комментарием командой ***git commit -m***. Осталось загрузить содержимое локального репозитория на GitHub. 
За это отвечает команда ***git push*** (от англ. push — «толкать»).
В первый раз эту команду нужно вызвать с флагом ***-u*** и параметрами ***origin*** (имя удалённого репозитория) и main или master (название текущей ветки). Флаг ***-u*** свяжет локальную ветку с одноимённой удалённой. 
Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.
~~~
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master. 
~~~

# Хеш — идентификатор коммита

Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint).
Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит.
Git хеширует (преобразует) информацию о коммите с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

Для вызова списока коммитов в коммандной строке написать ***git log***.
Элементы в списке комитов:
	* строка из цифр и латинских букв после слова commit — это хеш коммита;
	* Author — имя автора и его электронная почта;
	* Date — дата и время создания коммита;
	* в конце находится сообщение коммита.

Получить сокращённый лог можно с помощью команды — ***git log --oneline***.
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда ***git log --oneline*** автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в 
пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

# Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый).
Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.

# Статусы файлов в Git

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.
	* untracked (англ. «неотслеживаемый»)
	  Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.
	  
	* staged (англ. «подготовленный»)
	  После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

	* tracked (англ. «отслеживаемый»)
	  Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.
	
	* modified (англ. «изменённый»)
	  Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.
	  
Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.	  